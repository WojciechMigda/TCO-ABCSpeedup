/*******************************************************************************
 * Copyright (c) 2015 Wojciech Migda
 * All rights reserved
 * Distributed under the terms of the GNU LGPL v3
 *******************************************************************************
 *
 * Filename: timestamp.hpp
 *
 * Description:
 *      description
 *
 * Authors:
 *          Wojciech Migda (wm)
 *
 *******************************************************************************
 * History:
 * --------
 * Date         Who  Ticket     Description
 * ----------   ---  ---------  ------------------------------------------------
 * 2015-01-16   wm              Initial version
 *
 ******************************************************************************/

#ifndef TIMESTAMP_HPP_
#define TIMESTAMP_HPP_

#include <chrono>
#include <string>

struct Timestamp
{
    typedef std::chrono::steady_clock::time_point timepoint_type;
    explicit Timestamp(timepoint_type start)
    :
        m_start(start)
    {

    }

    std::string now(timepoint_type moment)
    {
//        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(moment - m_start).count();
//        return "[" + std::to_string(duration) + " us]";

        std::size_t duration = std::chrono::duration_cast<std::chrono::milliseconds>(moment - m_start).count();
        return "[" + std::to_string(duration) + " ms]";
    }

private:
    const timepoint_type m_start;
};

#endif /* TIMESTAMP_HPP_ */
/*******************************************************************************
 *
 * Filename: json.hpp
 *
 * Description:
 *      description
 *
 *******************************************************************************
 * History:
 * --------
 * Date         Who  Ticket     Description
 * ----------   ---  ---------  ------------------------------------------------
 * 2015-01-16   xx              Initial version
 *
 ******************************************************************************/
#ifndef JSON_HPP_
#define JSON_HPP_

#include <string>
#include <map>
#include <limits>
#include <istream>
#include <vector>
#include <cassert>
#include <sstream>
#include <iomanip>

// jsonxx versioning: major.minor-extra where
// major = { number }
// minor = { number }
// extra = { 'a':alpha, 'b':beta, 'rc': release candidate, 'r': release, 's':stable }
#define JSONXX_MAJOR    "0"
#define JSONXX_MINOR    "22"
#define JSONXX_EXTRA    "a"
#define JSONXX_VERSION  JSONXX_MAJOR "." JSONXX_MINOR "-" JSONXX_EXTRA
#define JSONXX_XML_TAG  "<!-- generated by jsonxx " JSONXX_VERSION " -->"

#if __cplusplus > 199711L
#define JSONXX_COMPILER_HAS_CXX11 1
#elif defined(_MSC_VER) && _MSC_VER > 1700
#define JSONXX_COMPILER_HAS_CXX11 1
#else
#define JSONXX_COMPILER_HAS_CXX11 0
#endif

#define JSONXX_ASSERT(...) do { if( jsonxx::Assertions ) \
  jsonxx::assertion(__FILE__,__LINE__,#__VA_ARGS__,bool(__VA_ARGS__)); } while(0)

namespace jsonxx {

// Settings
enum Settings {
  // constants
  Enabled = true,
  Disabled = false,
  Permissive = true,
  Strict = false,
  // values
  Parser = Permissive,  // permissive or strict parsing
  UnquotedKeys = Disabled, // support of unquoted keys
  Assertions = Enabled  // enabled or disabled assertions (these asserts work both in DEBUG and RELEASE builds)
};

enum Format {
  JSON      = 0,     // JSON output
  JSONx     = 1,     // XML output, JSONx  format. see http://goo.gl/I3cxs
};

// Types
typedef long double Number;
typedef bool Boolean;
typedef std::string String;
struct Null {};
class Value;
class Object;
class Array;

// Identity meta-function
template <typename T>
struct identity {
  typedef T type;
};

// Detail
void assertion( const char *file, int line, const char *expression, bool result );

// A JSON Object
class Object {
 public:
  Object();
  ~Object();

  template <typename T>
  bool has(const std::string& key) const;

  // Always call has<>() first. If the key doesn't exist, consider
  // the behavior undefined.
  template <typename T>
  T& get(const std::string& key);
  template <typename T>
  const T& get(const std::string& key) const;

  template <typename T>
  const T& get(const std::string& key, const typename identity<T>::type& default_value) const;

  size_t size() const;
  bool empty() const;

  const std::map<std::string, Value*>& kv_map() const;

  void reset();
  bool parse(std::istream &input);
  bool parse(const std::string &input);
  typedef std::map<std::string, Value*> container;
  void import( const Object &other );
  void import( const std::string &key, const Value &value );
  Object &operator<<(const Value &value);
  Object &operator<<(const Object &value);
  Object &operator=(const Object &value);
  Object(const Object &other);
  Object(const std::string &key, const Value &value);
  template<size_t N>
  Object(const char (&key)[N], const Value &value) {
    import(key,value);
  }
  template<typename T>
  Object &operator<<(const T &value);

 protected:
  static bool parse(std::istream& input, Object& object);
  container value_map_;
  std::string odd;
};

class Array {
 public:
  Array();
  ~Array();

  size_t size() const;
  bool empty() const;

  template <typename T>
  bool has(unsigned int i) const;

  template <typename T>
  T& get(unsigned int i);
  template <typename T>
  const T& get(unsigned int i) const;

  template <typename T>
  const T& get(unsigned int i, const typename identity<T>::type& default_value) const;

  const std::vector<Value*>& values() const {
    return values_;
  }

  void reset();
  bool parse(std::istream &input);
  bool parse(const std::string &input);
  typedef std::vector<Value*> container;
  void import(const Array &other);
  void import(const Value &value);
  Array &operator<<(const Array &other);
  Array &operator<<(const Value &value);
  Array &operator=(const Array &other);
  Array &operator=(const Value &value);
  Array(const Array &other);
  Array(const Value &value);
 protected:
  static bool parse(std::istream& input, Array& array);
  container values_;
};

// A value could be a number, an array, a string, an object, a
// boolean, or null
class Value {
 public:

  Value();
  ~Value() { reset(); }
  void reset();

  template<typename T>
  void import( const T & ) {
    reset();
    type_ = INVALID_;
    // debug
    // std::cout << "[WARN] No support for " << typeid(t).name() << std::endl;
  }
  void import( const bool &b ) {
    reset();
    type_ = BOOL_;
    bool_value_ = b;
  }
#define $number(TYPE) \
  void import( const TYPE &n ) { \
    reset(); \
    type_ = NUMBER_; \
    number_value_ = static_cast<long double>(n); \
  }
  $number( char )
  $number( int )
  $number( long )
  $number( long long )
  $number( unsigned char )
  $number( unsigned int )
  $number( unsigned long )
  $number( unsigned long long )
  $number( float )
  $number( double )
  $number( long double )
#undef $number
#if JSONXX_COMPILER_HAS_CXX11 > 0
  void import( const std::nullptr_t & ) {
    reset();
    type_ = NULL_;
  }
#endif
  void import( const Null & ) {
    reset();
    type_ = NULL_;
  }
  void import( const String &s ) {
    reset();
    type_ = STRING_;
    *( string_value_ = new String() ) = s;
  }
  void import( const Array &a ) {
    reset();
    type_ = ARRAY_;
    *( array_value_ = new Array() ) = a;
  }
  void import( const Object &o ) {
    reset();
    type_ = OBJECT_;
    *( object_value_ = new Object() ) = o;
  }
  void import( const Value &other ) {
    if (this != &other)
    switch (other.type_) {
      case NULL_:
        import( Null() );
        break;
      case BOOL_:
        import( other.bool_value_ );
        break;
      case NUMBER_:
        import( other.number_value_ );
        break;
      case STRING_:
        import( *other.string_value_ );
        break;
      case ARRAY_:
        import( *other.array_value_ );
        break;
      case OBJECT_:
        import( *other.object_value_ );
        break;
      case INVALID_:
        type_ = INVALID_;
        break;
      default:
        JSONXX_ASSERT( !"not implemented" );
    }
  }
  template<typename T>
  Value &operator <<( const T &t ) {
    import(t);
    return *this;
  }
  template<typename T>
  Value &operator =( const T &t ) {
    reset();
    import(t);
    return *this;
  }
  Value(const Value &other);
  template<typename T>
  Value( const T&t ) : type_(INVALID_) { import(t); }
  template<size_t N>
  Value( const char (&t)[N] ) : type_(INVALID_) { import( std::string(t) ); }

  bool parse(std::istream &input);
  bool parse(const std::string &input);

  template<typename T>
  bool is() const;
  template<typename T>
  T& get();
  template<typename T>
  const T& get() const;

  bool empty() const;

 public:
  enum {
    NUMBER_,
    STRING_,
    BOOL_,
    NULL_,
    ARRAY_,
    OBJECT_,
    INVALID_
  } type_;
  union {
    Number number_value_;
    String* string_value_;
    Boolean bool_value_;
    Array* array_value_;
    Object* object_value_;
  };

protected:
  static bool parse(std::istream& input, Value& value);
};

template <typename T>
bool Array::has(unsigned int i) const {
  if (i >= size()) {
    return false;
  } else {
    Value* v = values_.at(i);
    return v->is<T>();
  }
}

template <typename T>
T& Array::get(unsigned int i) {
  JSONXX_ASSERT(i < size());
  Value* v = values_.at(i);
  return v->get<T>();
}

template <typename T>
const T& Array::get(unsigned int i) const {
  JSONXX_ASSERT(i < size());
  const Value* v = values_.at(i);
  return v->get<T>();
}

template <typename T>
const T& Array::get(unsigned int i, const typename identity<T>::type& default_value) const {
  if(has<T>(i)) {
    const Value* v = values_.at(i);
    return v->get<T>();
  } else {
    return default_value;
  }
}

template <typename T>
bool Object::has(const std::string& key) const {
  container::const_iterator it(value_map_.find(key));
  return it != value_map_.end() && it->second->is<T>();
}

template <typename T>
T& Object::get(const std::string& key) {
  JSONXX_ASSERT(has<T>(key));
  return value_map_.find(key)->second->get<T>();
}

template <typename T>
const T& Object::get(const std::string& key) const {
  JSONXX_ASSERT(has<T>(key));
  return value_map_.find(key)->second->get<T>();
}

template <typename T>
const T& Object::get(const std::string& key, const typename identity<T>::type& default_value) const {
  if (has<T>(key)) {
    return value_map_.find(key)->second->get<T>();
  } else {
    return default_value;
  }
}

template<>
inline bool Value::is<Value>() const {
    return true;
}

template<>
inline bool Value::is<Null>() const {
  return type_ == NULL_;
}

template<>
inline bool Value::is<Boolean>() const {
  return type_ == BOOL_;
}

template<>
inline bool Value::is<String>() const {
  return type_ == STRING_;
}

template<>
inline bool Value::is<Number>() const {
  return type_ == NUMBER_;
}

template<>
inline bool Value::is<Array>() const {
  return type_ == ARRAY_;
}

template<>
inline bool Value::is<Object>() const {
  return type_ == OBJECT_;
}

template<>
inline Value& Value::get<Value>() {
    return *this;
}

template<>
inline const Value& Value::get<Value>() const {
    return *this;
}

template<>
inline bool& Value::get<Boolean>() {
  JSONXX_ASSERT(is<Boolean>());
  return bool_value_;
}

template<>
inline std::string& Value::get<String>() {
  JSONXX_ASSERT(is<String>());
  return *string_value_;
}

template<>
inline Number& Value::get<Number>() {
  JSONXX_ASSERT(is<Number>());
  return number_value_;
}

template<>
inline Array& Value::get<Array>() {
  JSONXX_ASSERT(is<Array>());
  return *array_value_;
}

template<>
inline Object& Value::get<Object>() {
  JSONXX_ASSERT(is<Object>());
  return *object_value_;
}

template<>
inline const Boolean& Value::get<Boolean>() const {
  JSONXX_ASSERT(is<Boolean>());
  return bool_value_;
}

template<>
inline const String& Value::get<String>() const {
  JSONXX_ASSERT(is<String>());
  return *string_value_;
}

template<>
inline const Number& Value::get<Number>() const {
  JSONXX_ASSERT(is<Number>());
  return number_value_;
}

template<>
inline const Array& Value::get<Array>() const {
  JSONXX_ASSERT(is<Array>());
  return *array_value_;
}

template<>
inline const Object& Value::get<Object>() const {
  JSONXX_ASSERT(is<Object>());
  return *object_value_;
}

template<typename T>
inline Object &Object::operator<<(const T &value) {
  return *this << Value(value), *this;
}

}  // namespace jsonxx

#if defined(NDEBUG) || defined(_NDEBUG)
#   define JSONXX_REENABLE_NDEBUG
#   undef  NDEBUG
#   undef _NDEBUG
#endif
void jsonxx::assertion( const char *file, int line, const char *expression, bool result ) {
    if( !result ) {
        fprintf( stderr, "[JSONXX] expression '%s' failed at %s:%d -> ", expression, file, line );
        assert( 0 );
    }
}
#if defined(JSONXX_REENABLE_NDEBUG)
#   define  NDEBUG
#   define _NDEBUG
#endif
namespace jsonxx {

//static_assert( sizeof(unsigned long long) < sizeof(long double), "'long double' cannot hold 64bit values in this compiler :(");

bool match(const char* pattern, std::istream& input);
bool parse_array(std::istream& input, Array& array);
bool parse_bool(std::istream& input, Boolean& value);
bool parse_comment(std::istream &input);
bool parse_null(std::istream& input);
bool parse_number(std::istream& input, Number& value);
bool parse_object(std::istream& input, Object& object);
bool parse_string(std::istream& input, String& value);
bool parse_identifier(std::istream& input, String& value);
bool parse_value(std::istream& input, Value& value);

// Try to consume characters from the input stream and match the
// pattern string.
bool match(const char* pattern, std::istream& input) {
    input >> std::ws;
    const char* cur(pattern);
    char ch(0);
    while(input && !input.eof() && *cur != 0) {
        input.get(ch);
        if (ch != *cur) {
            input.putback(ch);
            if( parse_comment(input) )
                continue;
            while (cur > pattern) {
                cur--;
                input.putback(*cur);
            }
            return false;
        } else {
            cur++;
        }
    }
    return *cur == 0;
}

bool parse_string(std::istream& input, String& value) {
    char ch = '\0', delimiter = '"';
    if (!match("\"", input))  {
        if (Parser == Strict) {
            return false;
        }
        delimiter = '\'';
        if (input.peek() != delimiter) {
            return false;
        }
        input.get(ch);
    }
    while(!input.eof() && input.good()) {
        input.get(ch);
        if (ch == delimiter) {
            break;
        }
        if (ch == '\\') {
            input.get(ch);
            switch(ch) {
                case '\\':
                case '/':
                    value.push_back(ch);
                    break;
                case 'b':
                    value.push_back('\b');
                    break;
                case 'f':
                    value.push_back('\f');
                    break;
                case 'n':
                    value.push_back('\n');
                    break;
                case 'r':
                    value.push_back('\r');
                    break;
                case 't':
                    value.push_back('\t');
                    break;
                case 'u': {
                        int i;
                        std::stringstream ss;
                        for( i = 0; (!input.eof() && input.good()) && i < 4; ++i ) {
                            input.get(ch);
                            ss << std::hex << ch;
                        }
                        if( input.good() && (ss >> i) )
                            value.push_back(i);
                    }
                    break;
                default:
                    if (ch != delimiter) {
                        value.push_back('\\');
                        value.push_back(ch);
                    } else value.push_back(ch);
                    break;
            }
        } else {
            value.push_back(ch);
        }
    }
    if (input && ch == delimiter) {
        return true;
    } else {
        return false;
    }
}

bool parse_identifier(std::istream& input, String& value) {
    input >> std::ws;

    char ch = '\0', delimiter = ':';
    bool first = true;

    while(!input.eof() && input.good()) {
        input.get(ch);

        if (ch == delimiter) {
            input.unget();
            break;
        }

        if(first) {
            if ((ch != '_' && ch != '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) {
                return false;
            }
            first = false;
        }
        if(ch == '_' || ch == '$' ||
            (ch >= 'a' && ch <= 'z') ||
            (ch >= 'A' && ch <= 'Z') ||
            (ch >= '0' && ch <= '9')) {
            value.push_back(ch);
        }
        else if(ch == '\t' || ch == ' ') {
            input >> std::ws;
        }
    }
    if (input && ch == delimiter) {
        return true;
    } else {
        return false;
    }
}

bool parse_number(std::istream& input, Number& value) {
    input >> std::ws;
    std::streampos rollback = input.tellg();
    input >> value;
    if (input.fail()) {
        input.clear();
        input.seekg(rollback);
        return false;
    }
    return true;
}

bool parse_bool(std::istream& input, Boolean& value) {
    if (match("true", input))  {
        value = true;
        return true;
    }
    if (match("false", input)) {
        value = false;
        return true;
    }
    return false;
}

bool parse_null(std::istream& input) {
    if (match("null", input))  {
        return true;
    }
    if (Parser == Strict) {
        return false;
    }
    return (input.peek()==',');
}

bool parse_array(std::istream& input, Array& array) {
    return array.parse(input);
}

bool parse_object(std::istream& input, Object& object) {
    return object.parse(input);
}

bool parse_comment(std::istream &input) {
    if( Parser == Permissive )
    if( !input.eof() && input.peek() == '/' )
    {
        char ch0(0);
        input.get(ch0);

        if( !input.eof() )
        {
            char ch1(0);
            input.get(ch1);

            if( ch0 == '/' && ch1 == '/' )
            {
                // trim chars till \r or \n
                for( char ch(0); !input.eof() && (input.peek() != '\r' && input.peek() != '\n'); )
                    input.get(ch);

                // consume spaces, tabs, \r or \n, in case no eof is found
                if( !input.eof() )
                    input >> std::ws;
                return true;
            }

            input.unget();
            input.clear();
        }

        input.unget();
        input.clear();
    }

    return false;
}

bool parse_value(std::istream& input, Value& value) {
    return value.parse(input);
}


Object::Object() : value_map_() {}

Object::~Object() {
    reset();
}

bool Object::parse(std::istream& input, Object& object) {
    object.reset();

    if (!match("{", input)) {
        return false;
    }
    if (match("}", input)) {
        return true;
    }

    do {
        std::string key;
        if(UnquotedKeys == Enabled) {
            if (!parse_identifier(input, key)) {
                if (Parser == Permissive) {
                    if (input.peek() == '}')
                        break;
                }
                return false;
            }
        }
        else {
            if (!parse_string(input, key)) {
                if (Parser == Permissive) {
                    if (input.peek() == '}')
                        break;
                }
                return false;
            }
        }
        if (!match(":", input)) {
            return false;
        }
        Value* v = new Value();
        if (!parse_value(input, *v)) {
            delete v;
            break;
        }
        object.value_map_[key] = v;
    } while (match(",", input));


    if (!match("}", input)) {
        return false;
    }

    return true;
}

Value::Value() : type_(INVALID_) {}

void Value::reset() {
    if (type_ == STRING_) {
        delete string_value_;
        string_value_ = 0;
    }
    else if (type_ == OBJECT_) {
        delete object_value_;
        object_value_ = 0;
    }
    else if (type_ == ARRAY_) {
        delete array_value_;
        array_value_ = 0;
    }
}

bool Value::parse(std::istream& input, Value& value) {
    value.reset();

    std::string string_value;
    if (parse_string(input, string_value)) {
        value.string_value_ = new std::string();
        value.string_value_->swap(string_value);
        value.type_ = STRING_;
        return true;
    }
    if (parse_number(input, value.number_value_)) {
        value.type_ = NUMBER_;
        return true;
    }

    if (parse_bool(input, value.bool_value_)) {
        value.type_ = BOOL_;
        return true;
    }
    if (parse_null(input)) {
        value.type_ = NULL_;
        return true;
    }
    if (input.peek() == '[') {
        value.array_value_ = new Array();
        if (parse_array(input, *value.array_value_)) {
            value.type_ = ARRAY_;
            return true;
        }
        delete value.array_value_;
    }
    value.object_value_ = new Object();
    if (parse_object(input, *value.object_value_)) {
        value.type_ = OBJECT_;
        return true;
    }
    delete value.object_value_;
    return false;
}

Array::Array() : values_() {}

Array::~Array() {
    reset();
}

bool Array::parse(std::istream& input, Array& array) {
    array.reset();

    if (!match("[", input)) {
        return false;
    }
    if (match("]", input)) {
        return true;
    }

    do {
        Value* v = new Value();
        if (!parse_value(input, *v)) {
            delete v;
            break;
        }
        array.values_.push_back(v);
    } while (match(",", input));

    if (!match("]", input)) {
        return false;
    }
    return true;
}

}  // namespace jsonxx


namespace jsonxx {
namespace {

typedef unsigned char byte;

//template<bool quote>
std::string escape_string( const std::string &input, const bool quote = false ) {
    static std::string map[256], *once = 0;
    if( !once ) {
        // base
        for( int i = 0; i < 256; ++i ) {
            map[ i ] = std::string() + char(i);
        }
        // non-printable
        for( int i = 0; i < 32; ++i ) {
            std::stringstream str;
            str << "\\u" << std::hex << std::setw(4) << std::setfill('0') << i;
            map[ i ] = str.str();
        }
        // exceptions
        map[ byte('"') ] = "\\\"";
        map[ byte('\\') ] = "\\\\";
        map[ byte('/') ] = "\\/";
        map[ byte('\b') ] = "\\b";
        map[ byte('\f') ] = "\\f";
        map[ byte('\n') ] = "\\n";
        map[ byte('\r') ] = "\\r";
        map[ byte('\t') ] = "\\t";

        once = map;
    }
    std::string output;
    output.reserve( input.size() * 2 + 2 ); // worst scenario
    if( quote ) output += '"';
    for( std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it )
        output += map[ byte(*it) ];
    if( quote ) output += '"';
    return output;
}


namespace json {

    std::string remove_last_comma( const std::string &_input ) {
        std::string input( _input );
        size_t size = input.size();
        if( size > 2 )
            if( input[ size - 2 ] == ',' )
                input[ size - 2 ] = ' ';
        return input;
    }

    std::string tag( unsigned format, unsigned depth, const std::string &name, const jsonxx::Value &t) {
        std::stringstream ss;
        const std::string tab(depth, '\t');

        if( !name.empty() )
            ss << tab << '\"' << escape_string( name ) << '\"' << ':' << ' ';
        else
            ss << tab;

        switch( t.type_ )
        {
            default:
            case jsonxx::Value::NULL_:
                ss << "null";
                return ss.str() + ",\n";

            case jsonxx::Value::BOOL_:
                ss << ( t.bool_value_ ? "true" : "false" );
                return ss.str() + ",\n";

            case jsonxx::Value::ARRAY_:
                ss << "[\n";
                for(Array::container::const_iterator it = t.array_value_->values().begin(),
                    end = t.array_value_->values().end(); it != end; ++it )
                  ss << tag( format, depth+1, std::string(), **it );
                return remove_last_comma( ss.str() ) + tab + "]" ",\n";

            case jsonxx::Value::STRING_:
                ss << '\"' << escape_string( *t.string_value_ ) << '\"';
                return ss.str() + ",\n";

            case jsonxx::Value::OBJECT_:
                ss << "{\n";
                for(Object::container::const_iterator it=t.object_value_->kv_map().begin(),
                    end = t.object_value_->kv_map().end(); it != end ; ++it)
                  ss << tag( format, depth+1, it->first, *it->second );
                return remove_last_comma( ss.str() ) + tab + "}" ",\n";

            case jsonxx::Value::NUMBER_:
                // max precision
                ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1);
                ss << t.number_value_;
                return ss.str() + ",\n";
        }
    }
} // namespace jsonxx::anon::json


} // namespace jsonxx::anon

Object::Object(const Object &other) {
  import(other);
}
Object::Object(const std::string &key, const Value &value) {
  import(key,value);
}
void Object::import( const Object &other ) {
  odd.clear();
  if (this != &other) {
    // default
    container::const_iterator
        it = other.value_map_.begin(),
        end = other.value_map_.end();
    for (/**/ ; it != end ; ++it) {
      container::iterator found = value_map_.find(it->first);
      if( found != value_map_.end() ) {
        delete found->second;
      }
      value_map_[ it->first ] = new Value( *it->second );
    }
  } else {
    // recursion is supported here
    import( Object(*this) );
  }
}
void Object::import( const std::string &key, const Value &value ) {
  odd.clear();
  container::iterator found = value_map_.find(key);
  if( found != value_map_.end() ) {
    delete found->second;
  }
  value_map_[ key ] = new Value( value );
}
Object &Object::operator=(const Object &other) {
  odd.clear();
  if (this != &other) {
    reset();
    import(other);
  }
  return *this;
}
Object &Object::operator<<(const Value &value) {
  if (odd.empty()) {
    odd = value.get<String>();
  } else {
    import( Object(odd, value) );
    odd.clear();
  }
  return *this;
}
Object &Object::operator<<(const Object &value) {
  import( std::string(odd),value);
  odd.clear();
  return *this;
}
size_t Object::size() const {
  return value_map_.size();
}
bool Object::empty() const {
  return value_map_.size() == 0;
}
const std::map<std::string, Value*> &Object::kv_map() const {
  return value_map_;
}
void Object::reset() {
  container::iterator i;
  for (i = value_map_.begin(); i != value_map_.end(); ++i) {
    delete i->second;
  }
  value_map_.clear();
}
bool Object::parse(std::istream &input) {
  return parse(input,*this);
}
bool Object::parse(const std::string &input) {
  std::istringstream is( input );
  return parse(is,*this);
}


Array::Array(const Array &other) {
  import(other);
}
Array::Array(const Value &value) {
  import(value);
}
void Array::import(const Array &other) {
  if (this != &other) {
    // default
    container::const_iterator
        it = other.values_.begin(),
        end = other.values_.end();
    for (/**/ ; it != end; ++it) {
      values_.push_back( new Value(**it) );
    }
  } else {
    // recursion is supported here
    import( Array(*this) );
  }
}
void Array::import(const Value &value) {
  values_.push_back( new Value(value) );
}
size_t Array::size() const {
  return values_.size();
}
bool Array::empty() const {
  return values_.size() == 0;
}
void Array::reset() {
  for (container::iterator i = values_.begin(); i != values_.end(); ++i) {
    delete *i;
  }
  values_.clear();
}
bool Array::parse(std::istream &input) {
  return parse(input,*this);
}
bool Array::parse(const std::string &input) {
  std::istringstream is(input);
  return parse(is,*this);
}
Array &Array::operator<<(const Array &other) {
  import(other);
  return *this;
}
Array &Array::operator<<(const Value &value) {
  import(value);
  return *this;
}
Array &Array::operator=(const Array &other) {
  if( this != &other ) {
    reset();
    import(other);
  }
  return *this;
}
Array &Array::operator=(const Value &value) {
  reset();
  import(value);
  return *this;
}

Value::Value(const Value &other) : type_(INVALID_) {
  import( other );
}
bool Value::empty() const {
  if( type_ == INVALID_ ) return true;
  if( type_ == STRING_ && string_value_ == 0 ) return true;
  if( type_ == ARRAY_ && array_value_ == 0 ) return true;
  if( type_ == OBJECT_ && object_value_ == 0 ) return true;
  return false;
}
bool Value::parse(std::istream &input) {
  return parse(input,*this);
}
bool Value::parse(const std::string &input) {
  std::istringstream is( input );
  return parse(is,*this);
}

}  // namespace jsonxx




#endif /* JSON_HPP_ */
/*******************************************************************************
 *
 * Filename: seq.hpp
 *
 * Description:
 *      description
 *
 *******************************************************************************
 * History:
 * --------
 * Date         Who  Ticket     Description
 * ----------   ---  ---------  ------------------------------------------------
 * 2015-01-16   xx              Initial version
 *
 ******************************************************************************/

#ifndef SEQ_HPP_
#define SEQ_HPP_

#include <utility>
#include <string>
#include <vector>
#include <algorithm>
#include <cstring>

enum
{
    SEQ_MAXSIZE = 10000
};

bool operator<(std::pair<int, std::string>& p1, std::pair<int, std::string>& p2) {
    if (p1.first != p2.first) {
        return p1.first < p2.first;
    }
    return p1.second.compare(p2.second) < 0;
}

struct Seq {
    std::size_t m_clustno;
    std::string id;
    //std::string v_fam;
    std::string v_gene;
    std::string v_all;
    std::string j_gene;
    std::string j_all;
    std::string junc;
//    std::vector<std::pair<int, std::string>> muts;
    std::vector<std::pair<int, int>> muts;

    int hash_mut(const std::string & str) const
    {
        const char * p = str.c_str();
        return p[0] * 65536 + p[1] * 256 + p[2];
    }

    Seq(std::size_t clustno, jsonxx::Object& o, const std::string& junc_query)
    :
        m_clustno(clustno)
    {
        id = o.get<std::string>("seq_id");
        //v_fam = o.get<jsonxx::Object>("v_gene").get<std::string>("fam");
        v_gene = o.get<jsonxx::Object>("v_gene").get<std::string>("gene");
        v_all = o.get<jsonxx::Object>("v_gene").get<std::string>("all");
        j_gene = o.get<jsonxx::Object>("j_gene").get<std::string>("gene");
        j_all = o.get<jsonxx::Object>("j_gene").get<std::string>("all");
        junc = o.get<std::string>(junc_query);
        if (o.has<jsonxx::Object>("var_muts_nt")) {
            jsonxx::Array a = o.get<jsonxx::Object>("var_muts_nt").get<jsonxx::Array>("muts");
            muts.reserve(a.size());
            for (size_t i = 0; i < a.size(); i++) {
                muts.emplace_back(atoi(a.get<jsonxx::Object>(i).get<std::string>("loc").c_str()),
                    hash_mut(a.get<jsonxx::Object>(i).get<std::string>("mut"))
                );
            }
        }
        std::sort(muts.begin(), muts.end());
    }

//    Seq() {}
};

//bool serialize(Seq& seq, size_t* len, char(* data)[SEQ_MAXSIZE]) {
//    *len = sizeof(size_t) * 7 +
//        seq.id.length() +
//        seq.v_gene.length() +
//        seq.v_all.length() +
//        seq.j_gene.length() +
//        seq.j_all.length() +
//        seq.junc.length();
//    for (size_t i = 0; i < seq.muts.size(); i++) {
//        *len += sizeof(int) + sizeof(size_t) + seq.muts[i].second.length();
//    }
//    if (*len > SEQ_MAXSIZE) {
//        fprintf(stderr, "Seq too long\n");
//        return false;
//    }
//    size_t pos = 0;
//    *(size_t*)((*data) + pos) = seq.id.length();
//    pos += sizeof(size_t);
//    strcpy((*data) + pos, seq.id.c_str());
//    pos += seq.id.length();
//    *(size_t*)((*data) + pos) = seq.v_gene.length();
//    pos += sizeof(size_t);
//    strcpy((*data) + pos, seq.v_gene.c_str());
//    pos += seq.v_gene.length();
//    *(size_t*)((*data) + pos) = seq.v_all.length();
//    pos += sizeof(size_t);
//    strcpy((*data) + pos, seq.v_all.c_str());
//    pos += seq.v_all.length();
//    *(size_t*)((*data) + pos) = seq.j_gene.length();
//    pos += sizeof(size_t);
//    strcpy((*data) + pos, seq.j_gene.c_str());
//    pos += seq.j_gene.length();
//    *(size_t*)((*data) + pos) = seq.j_all.length();
//    pos += sizeof(size_t);
//    strcpy((*data) + pos, seq.j_all.c_str());
//    pos += seq.j_all.length();
//    *(size_t*)((*data) + pos) = seq.junc.length();
//    pos += sizeof(size_t);
//    strcpy((*data) + pos, seq.junc.c_str());
//    pos += seq.junc.length();
//    *(size_t*)((*data) + pos) = seq.muts.size();
//    pos += sizeof(size_t);
//    for (size_t i = 0; i < seq.muts.size(); i++) {
//        *(int*)((*data) + pos) = seq.muts[i].first;
//        pos += sizeof(int);
//        *(size_t*)((*data) + pos) = seq.muts[i].second.length();
//        pos += sizeof(size_t);
//        strcpy((*data) + pos, seq.muts[i].second.c_str());
//        pos += seq.muts[i].second.length();
//    }
//    if (pos != *len) {
//        fprintf(stderr, "serialize error\n");
//        return false;
//    }
//    return true;
//}
//
//void deserialize(char* data, Seq* seq) {
//    size_t pos = 0;
//    size_t len;
//
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->id.clear();
//    for (size_t i = 0; i < len; i++) {
//        seq->id.push_back(*(data + pos++));
//    }
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->v_gene.clear();
//    for (size_t i = 0; i < len; i++) {
//        seq->v_gene.push_back(*(data + pos++));
//    }
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->v_all.clear();
//    for (size_t i = 0; i < len; i++) {
//        seq->v_all.push_back(*(data + pos++));
//    }
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->j_gene.clear();
//    for (size_t i = 0; i < len; i++) {
//        seq->j_gene.push_back(*(data + pos++));
//    }
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->j_all.clear();
//    for (size_t i = 0; i < len; i++) {
//        seq->j_all.push_back(*(data + pos++));
//    }
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->junc.clear();
//    for (size_t i = 0; i < len; i++) {
//        seq->junc.push_back(*(data + pos++));
//    }
//    len = *(size_t*)(data + pos);
//    pos += sizeof(size_t);
//    seq->muts.clear();
//    for (size_t i = 0; i < len; i++) {
//        int loc = *(int *)(data + pos);
//        pos += sizeof(int);
//        std::string mut;
//        size_t len_mut = *(size_t*)(data + pos);
//        pos += sizeof(size_t);
//        for (size_t j = 0; j < len_mut; j++) {
//            mut.push_back(*(data + pos++));
//        }
//        seq->muts.emplace_back(loc, mut);
//    }
//}

#endif /* SEQ_HPP_ */
/*******************************************************************************
 * Copyright (c) 2015 Wojciech Migda
 * All rights reserved
 * Distributed under the terms of the GNU LGPL v3
 *******************************************************************************
 *
 * Filename: ABCSpeedup.hpp
 *
 * Description:
 *      description
 *
 * Authors:
 *          Wojciech Migda (wm)
 *
 *******************************************************************************
 * History:
 * --------
 * Date         Who  Ticket     Description
 * ----------   ---  ---------  ------------------------------------------------
 * 2015-01-15   wm              Initial version
 *
 ******************************************************************************/

/*
 * IDEAS:
 * 1. naive: return separate results from each batch (testing the baseline)
 * 2. merge clusters from batches, skip those with distance > thr1, merge
 *    those with distance < thr2, for the gray zone: either leave them separate
 *    or repeat the process:)
 * 3. another batch-based approach: align dendrograms from batches, then apply
 *    flat clusters on top of the combined result, (CCLS-11-04 paper ???)
 * 4. probabilistic: create random batch, repeat clustering and collect results,
 *    somehow use the statistics (which?) to retrieve cluster assignments. (too slow)
 */
#ifndef ABCSPEEDUP_HPP_
#define ABCSPEEDUP_HPP_

//#pragma GCC optimize ( "-Ofast" )
#pragma GCC optimize ( "-ffast-math" )
#pragma GCC optimize ( "-fopenmp" )
#pragma GCC target ( "sse2" )
//#pragma GCC target ( "inline-stringops-dynamically" ) // not really
//#pragma GCC target ( "inline-all-stringops" ) // not really
//#pragma GCC target ( "fpmath=sse" )


#include <vector>
#include <iostream>
#include <string>
#include <utility>
#include <algorithm>
#include <memory>
#include <cmath>
#include <cassert>
#include <cfenv>
#include <iterator>

typedef float real_t;
//typedef int16_t real_t;

void done(void)
{
    std::cerr << "Done!" << std::endl << std::endl;
}

std::string vs_concat(std::vector<std::string> && vs)
{
    std::string result;

    std::for_each(vs.begin(), vs.end(),
        [&result](std::string & s)
        {
            std::string s_(std::move(s));
            const char * trimpoint = std::find_if(s_.c_str(), s_.c_str() + s_.length(), [](const char ch){return ch != '0';});
            result.append(trimpoint);
        }
    );

    return result;
}

enum {CACHE_LINE_SIZE = 32};

std::size_t fastLD(const std::string& s1, const std::string& s2)
{
    struct
    {
        uint8_t str1[CACHE_LINE_SIZE];
        uint8_t str2[CACHE_LINE_SIZE];
        uint8_t rowA[CACHE_LINE_SIZE * 2];
        uint8_t rowB[CACHE_LINE_SIZE * 2];
    } local __attribute__((aligned(32)));

    uint8_t * v0 = local.rowA;
    uint8_t * v1 = local.rowB;

    std::copy(s1.c_str(), s1.c_str() + s1.length(), local.str1);
    std::copy(s2.c_str(), s2.c_str() + s2.length(), local.str2);
    std::iota(v0, v0 + sizeof (local.rowA), 0);

    for (std::size_t iidx = 0; iidx < s1.length(); ++iidx)
    {
        v1[0] = iidx + 1;

        for (std::size_t jidx = 0; jidx < s2.length(); ++jidx)
        {
            bool cost = local.str1[iidx] != local.str2[jidx];

            const auto temp = std::min(v1[jidx] + 1, v0[jidx + 1] + 1); // dodaj 1 poza min

            v1[jidx + 1] = std::min(temp, v0[jidx] + cost);
        }

        std::swap(v0, v1);
    }

    return v0[s2.length()];
}

std::size_t LevenshteinDistance(const std::string& s1, const std::string& s2)
{
    if (s1.length() <= CACHE_LINE_SIZE && s2.length() <= CACHE_LINE_SIZE)
    {
        return fastLD(s1, s2);
    }

    std::size_t dp[s1.length() + 1][s2.length() + 1];
    for (std::size_t i = 0; i <= s1.length(); i++)
    {
        dp[i][0] = i;
    }
    for (std::size_t i = 0; i <= s2.length(); i++)
    {
        dp[0][i] = i;
    }
    for (std::size_t i = 1; i <= s1.length(); i++)
    {
        for (std::size_t j = 1; j <= s2.length(); j++)
        {
            dp[i][j] = std::min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            dp[i][j] = std::min(dp[i][j],
                dp[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 0 : 1));
        }
    }
    return dp[s1.length()][s2.length()];
}

double GlobalAlignment(
    const std::string& s1,
    const std::string& s2,
    double match,
    double mismatch,
    double gap,
    double extend)
{
    assert(gap == extend);
    double dp[s1.length() + 1][s2.length() + 1];
    for (size_t i = 0; i <= s1.length(); i++)
    {
        dp[i][0] = gap * i;
    }
    for (size_t i = 0; i <= s2.length(); i++)
    {
        dp[0][i] = gap * i;
    }
    for (size_t i = 1; i <= s1.length(); i++)
    {
        for (size_t j = 1; j <= s2.length(); j++)
        {
            dp[i][j] = dp[i - 1][j - 1]
                + (s1[i - 1] == s2[j - 1] ? match : mismatch);
            dp[i][j] = std::max(dp[i][j], dp[i - 1][j] + gap);
            dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + gap);
        }
    }
    return dp[s1.length()][s2.length()];
}

double GetLD(const Seq& s1, const Seq& s2)
{
    if (s1.junc.length() == s2.junc.length())
    {
        return s1.junc.length() - GlobalAlignment(s1.junc, s2.junc, 1, 0, -50, -50);
    }
    else
    {
        return LevenshteinDistance(s1.junc, s2.junc);
    }
}

double vCompare(const Seq& s1, const Seq& s2)
{
    if (0 != s1.v_gene.compare(s2.v_gene))
    {
        return 8;
    }
    if (0 != s1.v_all.compare(s2.v_all))
    {
        return 1;
    }
    return 0;
}

double jCompare(const Seq& s1, const Seq& s2)
{
    if (0 != s1.j_gene.compare(s2.j_gene))
    {
        return 8;
    }
    if (0 != s1.j_all.compare(s2.j_all))
    {
        return 1;
    }
    return 0;
}

double SharedMuts(const Seq& s1, const Seq& s2)
{
    if (0 == s1.id.compare(s2.id))
    {
        return 0.;
    }
    double bonus = 0.;
    size_t p1 = 0, p2 = 0;

    const std::size_t s1_muts_size = s1.muts.size();
    const std::size_t s2_muts_size = s2.muts.size();
    const decltype(&s1.muts[0]) s1_muts_p = s1.muts.data();
    const decltype(&s2.muts[0]) s2_muts_p = s2.muts.data();

    while (p1 < s1_muts_size && p2 < s2_muts_size)
    {
        if (s1_muts_p[p1] < s2_muts_p[p2])
        {
            p1++;
        }
        else if (s2_muts_p[p2] < s1_muts_p[p1])
        {
            p2++;
        }
        else
        {
            p1++;
            bonus += 0.35;
        }
    }
    return bonus;
}

//constexpr real_t CUTOFF = 32;
constexpr real_t CUTOFF = 0.32;

real_t GetScore(const Seq& s1, const Seq& s2)
{
    if (0 == s1.id.compare(s2.id))
    {
        return 0.;
    }

    const double vPenalty = vCompare(s1, s2);
    const double jPenalty = jCompare(s1, s2);
    const double lenPenalty = std::fabs(0. + s1.junc.length() - s2.junc.length()) * 2;
    const double editLength = (double)std::min(s1.junc.length(), s2.junc.length());

//    const double LD = GetLD(s1, s2);
    double LD;
//    const double LD = 0.0;
    if (vPenalty > 7 || jPenalty > 7 || lenPenalty > 7 )
    {
        LD = 6;
//        LD = GetLD(s1, s2);
    }
    else
    {
        LD = GetLD(s1, s2);
    }

    double mutBonus = SharedMuts(s1, s2);
//    double mutBonus = 0.0;

    if (mutBonus > (LD + vPenalty + jPenalty))
    {
        mutBonus = (LD + vPenalty + jPenalty - 0.001);
    }

//    const double score_no_LD = vPenalty + jPenalty + lenPenalty - mutBonus;
//
//    const double score = (score_no_LD < CUTOFF * editLength) ?
//        GetLD(s1, s2) + score_no_LD
//        :
//        score_no_LD;

    const double score = (LD + vPenalty + jPenalty + lenPenalty - mutBonus);
//    std::cerr << score << " " << LD << " " << vPenalty << " " << jPenalty << " " << lenPenalty << " " << mutBonus << std::endl;
    return (score / editLength);
}

std::unique_ptr<real_t[]> &&
BuildCondensedMatrix(
    std::vector<Seq *>::const_iterator cbegin,
    std::vector<Seq *>::const_iterator cend,
    std::unique_ptr<real_t[]> && scores)
{
    std::cerr << "Computing condensed matrix" << std::endl;

    const std::size_t NELEM = std::distance(cbegin, cend);

    std::vector<std::size_t> sumTable;
    sumTable.reserve(NELEM);
    sumTable.push_back(NELEM - 1);
    for (size_t i = 1; i < NELEM; i++)
    {
        sumTable.push_back(sumTable.back() + NELEM - i - 1);
    }

    const size_t nPairs = NELEM * (NELEM - 1) / 2;

#pragma omp parallel for
    for (std::size_t i = 0; i < nPairs; i++)
    {
        std::size_t first = std::lower_bound(sumTable.begin(), sumTable.end(), i + 1) -
            sumTable.begin();
        std::size_t second = NELEM - 1 - (sumTable[first] - (i + 1));
        //fprintf(stderr, "%lu %lu\n", first, second);
        scores[i] = GetScore(**(cbegin + first), **(cbegin + second));
    }

    return std::move(scores);
}

typedef int_fast32_t t_index;
typedef double t_float;

struct node
{
    t_index node1;
    t_index node2;
    t_float dist;

    inline friend bool operator<(const node & a, const node & b)
    {
        return (a.dist < b.dist);
    }
};

class cluster_result
{
private:
    std::unique_ptr<node[]> Z;
    t_index pos;

public:
    explicit cluster_result(const t_index size)
    :
        Z(new node[size]),
        pos(0)
    {
    }

    void append(const t_index node1, const t_index node2, const t_float dist)
    {
        Z[pos].node1 = node1;
        Z[pos].node2 = node2;
        Z[pos].dist = dist;
        ++pos;
    }

    node * operator[](const t_index idx) const
    {
        return &Z[idx];
    }

    /* Define several methods to postprocess the distances. All these functions
     are monotone, so they do not change the sorted order of distances. */

    void sqrt() const
    {
        std::for_each(&Z[0], &Z[pos],
            [](node & value)
            {
                value.dist = ::sqrt(value.dist);
            }
        );
    }

    void sqrt(const t_float) const
    { // ignore the argument
        sqrt();
    }

    void sqrtdouble(const t_float) const
    { // ignore the argument
        std::for_each(&Z[0], &Z[pos],
            [](node & value)
            {
                value.dist = ::sqrt(2 * value.dist);
            }
        );
    }

#ifdef R_pow
#define my_pow R_pow
#else
#define my_pow pow
#endif

    void power(const t_float p) const
    {
        t_float const q = 1 / p;
        std::for_each(&Z[0], &Z[pos],
            [&q](node & value)
            {
                value.dist = my_pow(value.dist, q);
            }
        );
    }

    void plusone(const t_float) const
    { // ignore the argument
        std::for_each(&Z[0], &Z[pos],
            [](node & value)
            {
                value.dist += 1;
            }
        );
    }

    void divide(const t_float denom) const
    {
        std::for_each(&Z[0], &Z[pos],
            [&denom](node & value)
            {
                value.dist /= denom;
            }
        );
    }
};

class nan_error{};
#ifdef FE_INVALID
class fenv_error{};
#endif

class doubly_linked_list
{
    /*
     Class for a doubly linked list. Initially, the list is the integer range
     [0, size]. We provide a forward iterator and a method to delete an index
     from the list.

     Typical use: for (i=L.start; L<size; i=L.succ[I])
     or
     for (i=somevalue; L<size; i=L.succ[I])
     */
public:
    t_index start;
    std::unique_ptr<t_index[]> succ;

private:
    std::unique_ptr<t_index[]> pred;
    // Not necessarily private, we just do not need it in this instance.

public:
    doubly_linked_list(const t_index size)
    // Initialize to the given size.
    :
        start(0),
        succ(new t_index[size + 1]),
        pred(new t_index[size + 1])
    {
        for (t_index i = 0; i < size; ++i)
        {
            pred[i + 1] = i;
            succ[i] = i + 1;
        }
        // pred[0] is never accessed!
        //succ[size] is never accessed!
    }

    ~doubly_linked_list()
    {
    }

    void remove(const t_index idx)
    {
        // Remove an index from the list.
        if (idx == start)
        {
            start = succ[idx];
        }
        else
        {
            succ[pred[idx]] = succ[idx];
            pred[succ[idx]] = pred[idx];
        }
        succ[idx] = 0; // Mark as inactive
    }

    bool is_inactive(t_index idx) const
    {
        return (succ[idx] == 0);
    }
};

/*
  Lookup function for a union-find data structure.

  The function finds the root of idx by going iteratively through all
  parent elements until a root is found. An element i is a root if
  nodes[i] is zero. To make subsequent searches faster, the entry for
  idx and all its parents is updated with the root element.
 */
class union_find
{
private:
    std::unique_ptr<t_index[]> parent;
    t_index nextparent;

public:
    union_find(const t_index size)
    :
        parent(new t_index[size > 0 ? 2 * size - 1 : 0]),
        nextparent(size)
    {
        std::fill(&parent[0], &parent[size > 0 ? 2 * size - 1 : 0], 0);
    }

    t_index Find(t_index idx) const
    {
        if (parent[idx] != 0)
        { // a → b
            t_index p = idx;
            idx = parent[idx];
            if (parent[idx] != 0)
            { // a → b → c
                do
                {
                    idx = parent[idx];
                } while (parent[idx] != 0);
                do
                {
                    t_index tmp = parent[p];
                    parent[p] = idx;
                    p = tmp;
                } while (parent[p] != idx);
            }
        }
        return idx;
    }

    void Union(const t_index node1, const t_index node2)
    {
        parent[node1] = parent[node2] = nextparent++;
    }
};

inline void f_average(
    real_t * const b,
    const real_t a,
    const t_float s,
    const t_float t)
{
    *b = s * a + t * (*b);
#ifndef FE_INVALID
#if HAVE_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
    if (fc_isnan(*b))
    {
        throw(nan_error());
    }
#if HAVE_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
#endif
}

template <typename t_members>
void NN_chain_core(
    const t_index N,
    std::unique_ptr<real_t[]> && D,
    std::unique_ptr<t_index[]> && members,
    cluster_result & Z2)
{
    /*
    N: integer
    D: condensed distance matrix N*(N-1)/2
    Z2: output data structure

    This is the NN-chain algorithm, described on page 86 in the following book:

    Fionn Murtagh, Multidimensional Clustering Algorithms,
    Vienna, Würzburg: Physica-Verlag, 1985.
     */
    const auto D_ = [&N, &D](const std::size_t r_, const std::size_t c_) -> real_t &
    {
        const std::size_t index = (static_cast<std::ptrdiff_t>(2*N-3-(r_))*(r_)>>1)+(c_)-1;

        return D[index];
    };

    t_index i;

    std::unique_ptr<t_index[]> NN_chain(new t_index[N]);
    t_index NN_chain_tip = 0;

    t_index idx1, idx2;

    t_float size1, size2;
    doubly_linked_list active_nodes(N);

    t_float min;

#ifdef FE_INVALID
    if (feclearexcept(FE_INVALID))
        throw fenv_error();
#endif

    for (t_index j = 0; j < N - 1; ++j)
    {
        if (NN_chain_tip <= 3)
        {
            NN_chain[0] = idx1 = active_nodes.start;
            NN_chain_tip = 1;

            idx2 = active_nodes.succ[idx1];
            min = D_(idx1, idx2);
            for (i = active_nodes.succ[idx2]; i < N; i = active_nodes.succ[i])
            {
                if (D_(idx1, i) < min)
                {
                    min = D_(idx1, i);
                    idx2 = i;
                }
            }
        }  // a: idx1   b: idx2
        else
        {
            NN_chain_tip -= 3;
            idx1 = NN_chain[NN_chain_tip - 1];
            idx2 = NN_chain[NN_chain_tip];
            min = idx1 < idx2 ? D_(idx1, idx2) : D_(idx2, idx1);
        }  // a: idx1   b: idx2

        do
        {
            NN_chain[NN_chain_tip] = idx2;

            for (i = active_nodes.start; i < idx2; i = active_nodes.succ[i])
            {
                if (D_(i, idx2) < min)
                {
                    min = D_(i, idx2);
                    idx1 = i;
                }
            }
            for (i = active_nodes.succ[idx2]; i < N; i = active_nodes.succ[i])
            {
                if (D_(idx2, i) < min)
                {
                    min = D_(idx2, i);
                    idx1 = i;
                }
            }

            idx2 = idx1;
            idx1 = NN_chain[NN_chain_tip++];

        } while (idx2 != NN_chain[NN_chain_tip - 2]);

//        std::cerr << "Z2.append " << idx1 << " " << idx2 << " " << min << std::endl;
        Z2.append(idx1, idx2, min);

        if (idx1 > idx2)
        {
            t_index tmp = idx1;
            idx1 = idx2;
            idx2 = tmp;
        }

        size1 = static_cast<t_float>(members[idx1]);
        size2 = static_cast<t_float>(members[idx2]);
        members[idx2] += members[idx1];

        // Remove the smaller index from the valid indices (active_nodes).
        active_nodes.remove(idx1);

        t_float s = size1 / (size1 + size2);
        t_float t = size2 / (size1 + size2);
        for (i = active_nodes.start; i < idx1; i = active_nodes.succ[i])
            f_average(&D_(i, idx2), D_(i, idx1), s, t);
        // Update the distance matrix in the range (idx1, idx2).
        for (; i < idx2; i = active_nodes.succ[i])
            f_average(&D_(i, idx2), D_(idx1, i), s, t);
        // Update the distance matrix in the range (idx2, N).
        for (i = active_nodes.succ[idx2]; i < N; i = active_nodes.succ[i])
            f_average(&D_(idx2, i), D_(idx1, i), s, t);

    }
#ifdef FE_INVALID
    if (fetestexcept(FE_INVALID))
        throw fenv_error();
#endif
}

class linkage_output
{
private:
    t_float * Z;

public:
    linkage_output(t_float * const Z_) :
        Z(Z_)
    {
    }

    void append(const t_index node1, const t_index node2, const t_float dist,
        const t_float size)
    {
        if (node1 < node2)
        {
            *(Z++) = static_cast<t_float>(node1);
            *(Z++) = static_cast<t_float>(node2);
        }
        else
        {
            *(Z++) = static_cast<t_float>(node2);
            *(Z++) = static_cast<t_float>(node1);
        }
        *(Z++) = dist;
        *(Z++) = size;
    }
};

template<const bool sorted>
std::unique_ptr<double[]> &&
generate_SciPy_dendrogram(
    std::unique_ptr<double[]> && Z,
    cluster_result && Z2,
    const t_index N)
{
    auto Z_ = [&Z](const t_index & _r, const t_index & _c) -> t_index
    {
        return (Z[_r * 4 + _c]);
    };
    auto size_ = [&N, &Z_](const t_index & r_) -> t_index
    {
        return (((r_ < N) ? 1 : Z_(r_ - N, 3)));
    };

    // The array "nodes" is a union-find data structure for the cluster
    // identities (only needed for unsorted cluster_result input).
    union_find nodes(sorted ? 0 : N);
    if (!sorted)
    {
        std::stable_sort(Z2[0], Z2[N - 1]);
    }

    linkage_output output(&Z[0]);
    t_index node1, node2;

    for (node const * NN = Z2[0]; NN != Z2[N - 1]; ++NN)
    {
        // Get two data points whose clusters are merged in step i.
        if (sorted)
        {
            node1 = NN->node1;
            node2 = NN->node2;
        }
        else
        {
            // Find the cluster identifiers for these points.
            node1 = nodes.Find(NN->node1);
            node2 = nodes.Find(NN->node2);
            // Merge the nodes in the union-find data structure by making them
            // children of a new node.
            nodes.Union(node1, node2);
        }
        output.append(node1, node2, NN->dist, size_(node1) + size_(node2));
    }

    return std::move(Z);
}

std::unique_ptr<double[]> &&
linkage(
    const t_index N,
    std::unique_ptr<real_t[]> && matrix,
    std::unique_ptr<double[]> && Z)
{
    std::unique_ptr<t_index[]> members(new t_index[N]);
    std::fill(&members[0], &members[N], 1);
    cluster_result Z2(N - 1);
    NN_chain_core<t_index>(N, std::move(matrix), std::move(members), Z2);
    Z = std::move(generate_SciPy_dendrogram<false>(std::move(Z), std::move(Z2), N));

//    std::cerr << "linkage "; std::copy(&Z[0], &Z[4 * (N - 1)], std::ostream_iterator<double>(std::cerr, " ")); std::cerr << std::endl;

    return std::move(Z);
}

enum
{
    CPY_LIN_LEFT  = 0,
    CPY_LIN_RIGHT = 1,
    CPY_LIN_DIST = 2,
    CPY_LIN_CNT = 3,
    CPY_LIS = 4
};

std::pair<std::unique_ptr<double[]>, std::unique_ptr<double[]>>
get_max_dist_for_each_cluster(
    std::unique_ptr<double[]> && Z,
    std::unique_ptr<double[]> && max_dists,
    const std::size_t N)
{
#define CPY_MAX(_x, _y) ((_x > _y) ? (_x) : (_y))
#define CPY_BITS_PER_CHAR (sizeof(unsigned char) * 8)
#define CPY_FLAG_ARRAY_SIZE_BYTES(num_bits) (CPY_CEIL_DIV((num_bits), \
                                                          CPY_BITS_PER_CHAR))
#define CPY_GET_BIT(_xx, i) (((_xx)[(i) / CPY_BITS_PER_CHAR] >> \
                             ((CPY_BITS_PER_CHAR-1) - \
                              ((i) % CPY_BITS_PER_CHAR))) & 0x1)
#define CPY_SET_BIT(_xx, i) ((_xx)[(i) / CPY_BITS_PER_CHAR] |= \
                              ((0x1) << ((CPY_BITS_PER_CHAR-1) \
                                         -((i) % CPY_BITS_PER_CHAR))))
#define CPY_CLEAR_BIT(_xx, i) ((_xx)[(i) / CPY_BITS_PER_CHAR] &= \
                              ~((0x1) << ((CPY_BITS_PER_CHAR-1) \
                                         -((i) % CPY_BITS_PER_CHAR))))

#ifndef CPY_CEIL_DIV
#define CPY_CEIL_DIV(x, y) ((((double)x)/(double)y) == \
                            ((double)((x)/(y))) ? ((x)/(y)) : ((x)/(y) + 1))
#endif
#ifdef CPY_DEBUG
#define CPY_DEBUG_MSG(...) fprintf(stderr, __VA_ARGS__)
#else
#define CPY_DEBUG_MSG(...)
#endif

    std::unique_ptr<int[]> curNode(new int [N]);
    std::size_t ndid, lid, rid; // TODO byly int-y
    int k;

    const int bff = CPY_FLAG_ARRAY_SIZE_BYTES(N);
    std::unique_ptr<unsigned char[]> lvisited(new unsigned char[bff]);
    std::unique_ptr<unsigned char[]> rvisited(new unsigned char[bff]);
    const double * Zrow;
    double max_dist;

    k = 0;
    curNode[k] = (N * 2) - 2;
    std::fill(&lvisited[0], &lvisited[bff], 0);
    std::fill(&rvisited[0], &rvisited[bff], 0);

    while (k >= 0)
    {
        ndid = curNode[k];
        Zrow = &Z[((ndid - N) * CPY_LIS)];
        lid = (int) Zrow[CPY_LIN_LEFT];
        rid = (int) Zrow[CPY_LIN_RIGHT];
        if (lid >= N && !CPY_GET_BIT(lvisited, ndid - N))
        {
            CPY_SET_BIT(lvisited, ndid - N);
            curNode[k + 1] = lid;
            k++;
            continue;
        }
        if (rid >= N && !CPY_GET_BIT(rvisited, ndid - N))
        {
            CPY_SET_BIT(rvisited, ndid - N);
            curNode[k + 1] = rid;
            k++;
            continue;
        }
        max_dist = Zrow[CPY_LIN_DIST];
        if (lid >= N)
        {
            max_dist = CPY_MAX(max_dist, max_dists[lid - N]);
        }
        if (rid >= N)
        {
            max_dist = CPY_MAX(max_dist, max_dists[rid - N]);
        }
        max_dists[ndid - N] = max_dist;
        CPY_DEBUG_MSG("i=%d maxdist[i]=%5.5f verif=%5.5f\n", ndid - N, max_dist,
            max_dists[ndid - N]);
        k--;
    }

    return std::make_pair(std::move(Z), std::move(max_dists));
}

std::unique_ptr<std::size_t[]>
form_flat_clusters_from_monotonic_criterion(
    std::unique_ptr<double[]> && Z,
    std::unique_ptr<double[]> && mono_crit,
    std::unique_ptr<std::size_t[]> && T,
    const real_t CUTOFF,
    const std::size_t N)
{
    std::unique_ptr<int[]> curNode(new int [N]);

    const int bff = CPY_FLAG_ARRAY_SIZE_BYTES(N);
    std::unique_ptr<unsigned char[]> lvisited(new unsigned char[bff]);
    std::unique_ptr<unsigned char[]> rvisited(new unsigned char[bff]);

    std::size_t ndid, lid, rid, nc;
    int k;
    int ms;
    double max_crit;
    const double * Zrow;

    /** number of clusters formed so far. */
    nc = 0;
    /** are we in part of a tree below the cutoff? .*/
    ms = -1;
    k = 0;
    curNode[k] = (N * 2) - 2;
    std::fill(&lvisited[0], &lvisited[bff], 0);
    std::fill(&rvisited[0], &rvisited[bff], 0);

    while (k >= 0)
    {
        ndid = curNode[k];
        Zrow = &Z[((ndid - N) * CPY_LIS)];
        lid = (int) Zrow[CPY_LIN_LEFT];
        rid = (int) Zrow[CPY_LIN_RIGHT];
        max_crit = mono_crit[ndid - N];
        CPY_DEBUG_MSG("cutoff: %5.5f maxc: %5.5f nc: %d\n", cutoff, max_crit, nc);
        if (ms == -1 && max_crit <= CUTOFF)
        {
            CPY_DEBUG_MSG("leader: i=%d\n", ndid);
            ms = k;
            nc++;
        }
        if (lid >= N && !CPY_GET_BIT(lvisited, ndid - N))
        {
            CPY_SET_BIT(lvisited, ndid - N);
            curNode[k + 1] = lid;
            k++;
            continue;
        }
        if (rid >= N && !CPY_GET_BIT(rvisited, ndid - N))
        {
            CPY_SET_BIT(rvisited, ndid - N);
            curNode[k + 1] = rid;
            k++;
            continue;
        }
        if (ndid >= N)
        {
            if (lid < N)
            {
                if (ms == -1)
                {
                    nc++;
                    T[lid] = nc;
                }
                else
                {
                    T[lid] = nc;
                }
            }
            if (rid < N)
            {
                if (ms == -1)
                {
                    nc++;
                    T[rid] = nc;
                }
                else
                {
                    T[rid] = nc;
                }
            }
            if (ms == k)
            {
                ms = -1;
            }
        }
        k--;
    }

    return std::move(T);
}

std::unique_ptr<std::size_t[]>
form_flat_clusters_from_dist(
    std::unique_ptr<double[]> && Z,
    std::unique_ptr<std::size_t[]> && T,
    const real_t CUTOFF,
    const std::size_t N)
{
    std::unique_ptr<double[]> max_dists(new double[N]);

    std::pair<std::unique_ptr<double[]>, std::unique_ptr<double[]>>
        result(get_max_dist_for_each_cluster(std::move(Z), std::move(max_dists), N));

    Z = std::move(result.first);
    max_dists = std::move(result.second);
//    std::cerr << "Z/m " << Z[0] << " " << max_dists[0] << std::endl;

    //CPY_DEBUG_MSG("cupid: n=%d cutoff=%5.5f MD[0]=%5.5f MD[n-1]=%5.5f\n", n, cutoff, max_dists[0], max_dists[n-2]);
    T = form_flat_clusters_from_monotonic_criterion(std::move(Z), std::move(max_dists), std::move(T), CUTOFF, N);

//    std::cerr << "flat_clusters "; std::copy(&T[0], &T[N], std::ostream_iterator<int>(std::cerr, " ")); std::cerr << std::endl;

    return std::move(T);
}

std::vector<std::size_t>
fcluster(std::vector<Seq *>::const_iterator cbegin, std::vector<Seq *>::const_iterator cend)
{
    std::cerr << std::endl << "start " << __FUNCTION__ << std::endl;
    std::cerr << "Processing " << std::distance(cbegin, cend) << " sequences" << std::endl;

    const std::size_t NELEM = std::distance(cbegin, cend);
    std::vector<std::size_t> result(std::distance(cbegin, cend));

    std::unique_ptr<real_t[]> dist_matrix(new real_t[NELEM * (NELEM - 1) / 2]);

    Timestamp then(std::chrono::steady_clock::now());
    dist_matrix = std::move(BuildCondensedMatrix(cbegin, cend, std::move(dist_matrix)));
    std::cerr << "It took " << then.now(std::chrono::steady_clock::now()) << std::endl;

    std::unique_ptr<double[]> linkage_matrix(new double[4 * (NELEM - 1)]);
    linkage_matrix = std::move(linkage(NELEM, std::move(dist_matrix), std::move(linkage_matrix)));

    std::unique_ptr<std::size_t[]> flat_cluster(new std::size_t[NELEM]);

    flat_cluster = form_flat_clusters_from_dist(
        std::move(linkage_matrix),
        std::move(flat_cluster),
        CUTOFF,
        NELEM);

    std::cerr << std::endl << "end " << __FUNCTION__ << std::endl;

    std::copy(&flat_cluster[0], &flat_cluster[NELEM], result.data());

    return result;
}

std::size_t
process_pseqs_in_batches(
    std::vector<Seq *> & pseqs,
    const std::size_t BATCH_SIZE,
    const std::size_t BACKSTEP_SIZE
    )
{
    const std::size_t N = pseqs.size();
    const std::size_t nbatch = (N + BATCH_SIZE - 1) / BATCH_SIZE;
    const std::size_t batch_size = N % nbatch ? 1 + N / nbatch : N / nbatch;

    std::cerr << "Doing " << nbatch << " batch(es), " << batch_size << " sequence(s) each." << std::endl;

    std::vector<Seq *>::const_iterator batch_pos = pseqs.cbegin();

    std::size_t max_cluster_no{0};
    std::size_t backstep{0};

    for (std::size_t bi{0}; batch_pos < pseqs.cend(); ++bi)
    {
        std::cerr << "Now doing batch no. " << (bi + 1) << std::endl;
        std::cerr << "Range: " << std::distance(pseqs.cbegin(), batch_pos) << " " << std::distance(pseqs.cbegin(), batch_pos + batch_size + backstep) << std::endl;

        std::vector<std::size_t> bres =
            std::move(fcluster(batch_pos, std::min(batch_pos + batch_size + backstep, pseqs.cend())));

        // backstep
        if (batch_pos + batch_size + backstep < pseqs.cend())
        {
            auto found = std::find(bres.cend() - BACKSTEP_SIZE, bres.cend(), bres.back());
            backstep = std::distance(found, bres.cend());
            std::cerr << "Backstep is " << backstep << std::endl << std::endl;
            backstep = backstep == BACKSTEP_SIZE ? 0 : backstep;
        }
        else
        {
            // for the last batch we process full results
            backstep = 0;
        }

        auto bres_backed_end = bres.cend() - backstep;

        const std::size_t max_b_cluster_no = *(std::max_element(bres.cbegin(), bres_backed_end));
        std::cerr << "Max received cluster no. " << max_b_cluster_no << std::endl;

        for (std::size_t idx{0}; idx < (std::size_t)std::distance(bres.cbegin(), bres_backed_end); ++idx)
        {
            const std::size_t offset = std::distance(pseqs.cbegin(), batch_pos);
            pseqs[offset + idx]->m_clustno = bres[idx] + max_cluster_no;
        }

        std::cerr << "Did " << std::distance(pseqs.cbegin(), batch_pos) << " assignments so far." << std::endl;
        std::cerr << "In this batch, front " << bres.front() << " to backstep " << *(bres_backed_end - 1) << ", back " << bres.back() << std::endl << std::endl;

        max_cluster_no += max_b_cluster_no;

        batch_pos += bres_backed_end - bres.cbegin();
    }

    return max_cluster_no;
}

void
rearrange_clusters(std::vector<Seq *> & pseqs)
{
    typedef std::pair<std::size_t, std::size_t> cluster_type;

    std::vector<cluster_type> clusters;

    std::size_t curr = 0;
    std::size_t next = 0;

    while (curr != pseqs.size())
    {
        while (next != pseqs.size() && pseqs[next]->m_clustno == pseqs[curr]->m_clustno)
        {
            ++next;
        }
        clusters.emplace_back(curr, next);
//        std::cerr << clusters.back().first << " " << clusters.back().second << std::endl;
        curr = next;
    }

    std::vector<cluster_type>::iterator cit1 = clusters.begin();
    std::vector<cluster_type>::iterator cit2 = std::next(cit1);
    std::vector<cluster_type>::iterator cit3 = std::prev(clusters.end());

    while (cit2 != std::prev(clusters.end()))
    {
        std::vector<cluster_type>::iterator cit3 = std::prev(clusters.end());
        do
        {
            if (GetScore(*pseqs[cit1->first], *pseqs[cit3->first]) < CUTOFF * 4)
            {
                cluster_type moved = *cit3;
                clusters.erase(cit3);
                clusters.insert(cit2, moved);
                ++cit2;
                continue;
            }
            --cit3;
        } while (cit3 != cit2);

//        cit1 = cit2;
        ++cit1;
        ++cit2;
    }

//    bool swapped = false;
//    do
//    {
//        swapped = false;
//        while (cit3 != clusters.end())
//        {
//            if (GetScore(*pseqs[cit1->first], *pseqs[cit2->first]) > GetScore(*pseqs[cit1->first], *pseqs[cit3->first]))
//            {
//                std::swap(*cit2, *cit3);
//            }
//            ++cit1;
//            ++cit2;
//            ++cit3;
//        }
//    } while (swapped);

    for (auto cluster : clusters)
    {
//        std::cerr << cluster.first << " " << cluster.second << std::endl;
    }

    std::vector<Seq *> collage;

    for (auto cluster : clusters)
    {
        std::copy(pseqs.cbegin() + cluster.first, pseqs.cbegin() + cluster.second, std::back_inserter(collage));
    }
    pseqs = collage;
}

std::vector<std::string>
fcluster_1(std::vector<Seq> && seqs)
{
    std::cerr << std::endl << "start " << __FUNCTION__ << std::endl;

    const std::size_t N = seqs.size();

    std::vector<Seq *> pseqs(N);
    std::transform(seqs.begin(), seqs.end(), pseqs.begin(),
        [](Seq & val)
        {
        return &val;
        }
    );

    auto seqp_comparator = [](const void * p, const void * q) -> int
    {
        const Seq * lhs = *(const Seq **)p;
        const Seq * rhs = *(const Seq **)q;

        const std::string & lhs_v = lhs->v_gene;
        const std::string & rhs_v = rhs->v_gene;

        const int v_rank = lhs_v.compare(rhs_v);
        if (v_rank == 0)
        {
            const std::string & lhs_j = lhs->j_gene;
            const std::string & rhs_j = rhs->j_gene;

            const int j_rank = lhs_j.compare(rhs_j);
            if (j_rank == 0)
            {
                return lhs->junc.compare(rhs->junc);
            }
            else
            {
                return j_rank;
            }
        }
        else
        {
            return v_rank;
        }
    };

    std::cerr << "Sorting sequences..." << std::endl;
    std::qsort(pseqs.data(), pseqs.size(), sizeof (*pseqs.data()), seqp_comparator);
    done();

    std::vector<std::string> result;

    std::size_t clustno = process_pseqs_in_batches(pseqs, 3000, 600);

    if (clustno > 2)
    {
        rearrange_clusters(pseqs);
        process_pseqs_in_batches(pseqs, 10000, 2000);
    }

//    std::transform(pseqs.cbegin(), pseqs.cend(), std::ostream_iterator<std::size_t>(std::cerr, "\n"),
//        [](const Seq * pseq)
//        {
//            return pseq->m_clustno;
//        }
//    );

    std::transform(seqs.cbegin(), seqs.cend(), std::back_inserter(result),
        [](const Seq & seq)
        {
            return std::to_string(seq.m_clustno);
        }
    );

    std::cerr << std::endl << "end " << __FUNCTION__ << std::endl;

    return result;
}

std::vector<std::string>
fcluster_2(std::vector<Seq> && seqs)
{
    std::cerr << std::endl << "start " << __FUNCTION__ << std::endl;

    const std::size_t N = seqs.size();

    std::vector<Seq *> pseqs(N);
    std::transform(seqs.begin(), seqs.end(), pseqs.begin(),
        [](Seq & val)
        {
        return &val;
        }
    );

    auto seqp_comparator = [](const void * p, const void * q) -> int
    {
        const Seq * lhs = *(const Seq **)p;
        const Seq * rhs = *(const Seq **)q;

        const std::string & lhs_v = lhs->v_gene;
        const std::string & rhs_v = rhs->v_gene;

        const int v_rank = lhs_v.compare(rhs_v);
        if (v_rank == 0)
        {
            const std::string & lhs_j = lhs->j_gene;
            const std::string & rhs_j = rhs->j_gene;

            const int j_rank = lhs_j.compare(rhs_j);
            if (j_rank == 0)
            {
                return lhs->junc.compare(rhs->junc);
            }
            else
            {
                return j_rank;
            }
        }
        else
        {
            return v_rank;
        }
    };

    std::cerr << "Sorting sequences..." << std::endl;
    std::qsort(pseqs.data(), pseqs.size(), sizeof (*pseqs.data()), seqp_comparator);

    done();

    std::vector<std::string> result;
    std::size_t curr_clust_no{1};

    for (auto it = pseqs.cbegin(); it < (pseqs.end() - 1); ++it)
    {
        (*it)->m_clustno = curr_clust_no;
        if (GetScore(**it, **(it + 1)) > CUTOFF)
        {
            ++curr_clust_no;
        }
//        std::cerr << (*it)->m_clustno << " " << GetScore(**it, **(it + 1)) << std::endl;
    }

    std::transform(seqs.cbegin(), seqs.cend(), std::back_inserter(result),
        [](const Seq & seq)
        {
            return std::to_string(seq.m_clustno);
        }
    );

    std::cerr << std::endl << "end " << __FUNCTION__ << std::endl;

    return result;
}

std::vector<std::string>
fcluster(std::vector<std::string> && json)
{
    std::cerr << "Consuming input collection..." << std::endl;
    Timestamp then1(std::chrono::steady_clock::now());
    std::string json_str{vs_concat(std::move(json))};
    std::cerr << "It took " << then1.now(std::chrono::steady_clock::now()) << std::endl;
    done();

    std::cerr << "Parsing JSON..." << std::endl;
    jsonxx::Array json_array;
    Timestamp then2(std::chrono::steady_clock::now());
    json_array.parse(json_str);
    std::cerr << "It took " << then2.now(std::chrono::steady_clock::now()) << std::endl;
    done();

    const std::size_t n = json_array.size();
    if (json_array.empty())
    {
        std::cerr << "Error - No Sequence in the input file." << std::endl;
        exit(0);
    }

    std::cerr << "Building sequences..." << std::endl;
    std::vector<Seq> seqs;
    for (size_t i = 0; i < json_array.size() && i < size_t(n); i++)
    {
        auto o = json_array.get<jsonxx::Object>(i);
        seqs.emplace_back(i, o, "junc_aa");
    }
    json_array.reset();
    done();
    std::cerr << "Got " << seqs.size() << " sequences." << std::endl;

    // Seqs are ready, do the hard work now

    std::vector<std::string> result = fcluster_1(std::move(seqs));
//    std::vector<std::string> result = fcluster_2(std::move(seqs));

    return result;
}

struct ABCSpeedup
{
    std::vector<std::string> cluster(std::vector<std::string> & json)
    {
        return fcluster(std::move(json));
    }
};

#endif /* ABCSPEEDUP_HPP_ */
